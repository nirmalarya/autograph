#!/usr/bin/env python3
"""
Feature #60 Validation: Vulnerability Scanning for Dependencies

Tests:
1. Run pip-audit on all backend services
2. Verify no critical vulnerabilities exist
3. Verify vulnerability scanning script exists and works
4. Verify CI/CD integration is configured
5. Verify pre-commit hook is available
6. Test that scan detects known vulnerabilities
7. Verify scan results are properly formatted
8. Check automated scanning documentation
"""

import subprocess
import json
import sys
from pathlib import Path
from typing import Dict, List, Tuple


class Feature60Validator:
    def __init__(self):
        self.project_root = Path(__file__).parent
        self.services_dir = self.project_root / "services"
        self.scripts_dir = self.project_root / "scripts"
        self.workflows_dir = self.project_root / ".github" / "workflows"
        self.test_results = []
        self.services = [
            "auth-service",
            "api-gateway",
            "diagram-service",
            "collaboration-service",
            "ai-service",
            "export-service",
            "git-service",
            "integration-hub"
        ]

    def log_test(self, test_name: str, passed: bool, details: str = ""):
        """Log test result"""
        status = "✅ PASS" if passed else "❌ FAIL"
        print(f"{status}: {test_name}")
        if details:
            print(f"   {details}")
        self.test_results.append({
            "test": test_name,
            "passed": passed,
            "details": details
        })

    def test_pip_audit_installed(self) -> bool:
        """Test 1: Verify pip-audit is available"""
        print("\n" + "="*80)
        print("TEST 1: Verify pip-audit is installed")
        print("="*80)

        try:
            result = subprocess.run(
                [sys.executable, "-m", "pip_audit", "--version"],
                capture_output=True,
                text=True,
                timeout=10
            )
            if result.returncode == 0:
                self.log_test(
                    "pip-audit installation",
                    True,
                    f"Version: {result.stdout.strip()}"
                )
                return True
            else:
                self.log_test(
                    "pip-audit installation",
                    False,
                    "pip-audit not found or not working"
                )
                return False
        except Exception as e:
            self.log_test("pip-audit installation", False, str(e))
            return False

    def test_scan_all_services(self) -> bool:
        """Test 2: Scan all services for vulnerabilities"""
        print("\n" + "="*80)
        print("TEST 2: Scan all backend services")
        print("="*80)

        all_clean = True
        critical_vulns = []

        for service_name in self.services:
            requirements_file = self.services_dir / service_name / "requirements.txt"

            if not requirements_file.exists():
                self.log_test(
                    f"Scan {service_name}",
                    False,
                    "requirements.txt not found"
                )
                all_clean = False
                continue

            try:
                result = subprocess.run(
                    [sys.executable, "-m", "pip_audit", "-r", str(requirements_file), "--format", "json"],
                    capture_output=True,
                    text=True,
                    timeout=60
                )

                if result.returncode == 0:
                    # No vulnerabilities
                    self.log_test(
                        f"Scan {service_name}",
                        True,
                        "No vulnerabilities found"
                    )
                else:
                    # Parse vulnerabilities
                    try:
                        data = json.loads(result.stdout)
                        vulns = data.get("vulnerabilities", [])

                        # Check for critical vulnerabilities
                        critical = [v for v in vulns if "CRITICAL" in v.get("id", "").upper() or
                                   "CVE-2024-12" in v.get("id", "") or "CVE-2025" in v.get("id", "")]

                        if critical:
                            critical_vulns.extend(critical)
                            self.log_test(
                                f"Scan {service_name}",
                                False,
                                f"Found {len(critical)} critical vulnerabilities"
                            )
                            all_clean = False
                        else:
                            self.log_test(
                                f"Scan {service_name}",
                                True,
                                f"Found {len(vulns)} non-critical vulnerabilities"
                            )
                    except json.JSONDecodeError:
                        self.log_test(
                            f"Scan {service_name}",
                            False,
                            "Failed to parse scan results"
                        )
                        all_clean = False

            except subprocess.TimeoutExpired:
                self.log_test(f"Scan {service_name}", False, "Scan timeout")
                all_clean = False
            except Exception as e:
                self.log_test(f"Scan {service_name}", False, str(e))
                all_clean = False

        if critical_vulns:
            self.log_test(
                "No critical vulnerabilities",
                False,
                f"Found {len(critical_vulns)} critical vulnerabilities"
            )
            return False
        else:
            self.log_test(
                "No critical vulnerabilities",
                True,
                "All services are clean or have only non-critical issues"
            )
            return all_clean

    def test_vulnerability_scan_script(self) -> bool:
        """Test 3: Verify vulnerability scanning script exists and works"""
        print("\n" + "="*80)
        print("TEST 3: Verify vulnerability scanning script")
        print("="*80)

        script_path = self.scripts_dir / "vulnerability_scan.py"

        if not script_path.exists():
            self.log_test(
                "Vulnerability scan script exists",
                False,
                f"Script not found at {script_path}"
            )
            return False

        self.log_test(
            "Vulnerability scan script exists",
            True,
            str(script_path)
        )

        # Test that script runs
        try:
            result = subprocess.run(
                [sys.executable, str(script_path)],
                capture_output=True,
                text=True,
                timeout=180,
                cwd=self.project_root
            )

            if result.returncode in [0, 2]:  # 0 = clean, 2 = warnings
                self.log_test(
                    "Vulnerability scan script runs",
                    True,
                    "Script executed successfully"
                )

                # Check if output file was created
                output_file = self.project_root / "vulnerability_scan_results.json"
                if output_file.exists():
                    self.log_test(
                        "Scan results JSON generated",
                        True,
                        str(output_file)
                    )
                    return True
                else:
                    self.log_test(
                        "Scan results JSON generated",
                        False,
                        "Results file not created"
                    )
                    return False
            else:
                self.log_test(
                    "Vulnerability scan script runs",
                    False,
                    f"Script exited with code {result.returncode}"
                )
                return False

        except subprocess.TimeoutExpired:
            self.log_test(
                "Vulnerability scan script runs",
                False,
                "Script timeout"
            )
            return False
        except Exception as e:
            self.log_test(
                "Vulnerability scan script runs",
                False,
                str(e)
            )
            return False

    def test_ci_cd_integration(self) -> bool:
        """Test 4: Verify CI/CD integration is configured"""
        print("\n" + "="*80)
        print("TEST 4: Verify CI/CD integration")
        print("="*80)

        workflow_file = self.workflows_dir / "vulnerability-scan.yml"

        if not workflow_file.exists():
            self.log_test(
                "GitHub Actions workflow exists",
                False,
                f"Workflow not found at {workflow_file}"
            )
            return False

        self.log_test(
            "GitHub Actions workflow exists",
            True,
            str(workflow_file)
        )

        # Validate workflow content
        try:
            content = workflow_file.read_text()

            checks = [
                ("pip-audit command", "pip_audit" in content),
                ("Service matrix", "matrix:" in content and "service:" in content),
                ("Scheduled runs", "schedule:" in content and "cron:" in content),
                ("Pull request triggers", "pull_request:" in content),
                ("Fail on vulnerabilities", "exit 1" in content),
                ("Upload artifacts", "upload-artifact" in content)
            ]

            all_passed = True
            for check_name, passed in checks:
                self.log_test(f"CI/CD: {check_name}", passed)
                if not passed:
                    all_passed = False

            return all_passed

        except Exception as e:
            self.log_test("CI/CD workflow validation", False, str(e))
            return False

    def test_pre_commit_hook(self) -> bool:
        """Test 5: Verify pre-commit hook is available"""
        print("\n" + "="*80)
        print("TEST 5: Verify pre-commit hook")
        print("="*80)

        hook_script = self.scripts_dir / "pre_commit_vulnerability_check.sh"

        if not hook_script.exists():
            self.log_test(
                "Pre-commit hook script exists",
                False,
                f"Script not found at {hook_script}"
            )
            return False

        self.log_test(
            "Pre-commit hook script exists",
            True,
            str(hook_script)
        )

        # Check if executable
        if hook_script.stat().st_mode & 0o111:
            self.log_test(
                "Pre-commit hook is executable",
                True
            )
        else:
            self.log_test(
                "Pre-commit hook is executable",
                False,
                "Script is not executable"
            )
            return False

        # Validate hook content
        try:
            content = hook_script.read_text()

            checks = [
                ("pip-audit command", "pip_audit" in content),
                ("Requirements check", "requirements.txt" in content),
                ("Vulnerability detection", "VULNERABILITIES_FOUND" in content),
                ("Exit on failure", "exit 1" in content)
            ]

            all_passed = True
            for check_name, passed in checks:
                self.log_test(f"Pre-commit: {check_name}", passed)
                if not passed:
                    all_passed = False

            return all_passed

        except Exception as e:
            self.log_test("Pre-commit hook validation", False, str(e))
            return False

    def test_scan_results_format(self) -> bool:
        """Test 6: Verify scan results are properly formatted"""
        print("\n" + "="*80)
        print("TEST 6: Verify scan results format")
        print("="*80)

        results_file = self.project_root / "vulnerability_scan_results.json"

        if not results_file.exists():
            self.log_test(
                "Scan results file exists",
                False,
                "Run vulnerability_scan.py first"
            )
            return False

        try:
            with open(results_file) as f:
                results = json.load(f)

            # Check structure
            required_keys = ["summary", "service_results"]
            summary_keys = [
                "total_services",
                "clean_services",
                "vulnerable_services",
                "total_vulnerabilities",
                "critical_count",
                "high_count"
            ]

            all_passed = True

            for key in required_keys:
                if key in results:
                    self.log_test(f"Results has '{key}' section", True)
                else:
                    self.log_test(f"Results has '{key}' section", False)
                    all_passed = False

            if "summary" in results:
                for key in summary_keys:
                    if key in results["summary"]:
                        self.log_test(f"Summary has '{key}'", True)
                    else:
                        self.log_test(f"Summary has '{key}'", False)
                        all_passed = False

            # Verify service results
            if "service_results" in results:
                services_scanned = len(results["service_results"])
                self.log_test(
                    f"Scanned {services_scanned} services",
                    services_scanned >= 8,
                    f"Expected at least 8, got {services_scanned}"
                )
            else:
                all_passed = False

            return all_passed

        except json.JSONDecodeError as e:
            self.log_test("Scan results JSON valid", False, str(e))
            return False
        except Exception as e:
            self.log_test("Scan results format validation", False, str(e))
            return False

    def test_documentation(self) -> bool:
        """Test 7: Verify documentation exists"""
        print("\n" + "="*80)
        print("TEST 7: Verify documentation")
        print("="*80)

        # Check if README mentions vulnerability scanning
        readme_file = self.project_root / "README.md"

        if readme_file.exists():
            content = readme_file.read_text().lower()
            has_vuln_docs = "vulnerabilit" in content or "security" in content

            self.log_test(
                "README mentions vulnerability scanning",
                has_vuln_docs,
                "Documentation should include security/vulnerability information"
            )
        else:
            self.log_test(
                "README exists",
                False,
                "README.md not found"
            )
            return False

        # Check if scripts have proper documentation
        scan_script = self.scripts_dir / "vulnerability_scan.py"
        if scan_script.exists():
            content = scan_script.read_text()
            has_docstring = '"""' in content or "'''" in content

            self.log_test(
                "Scan script has documentation",
                has_docstring
            )
            return has_docstring
        else:
            return False

    def test_complete_workflow(self) -> bool:
        """Test 8: Complete workflow validation"""
        print("\n" + "="*80)
        print("TEST 8: Complete workflow validation")
        print("="*80)

        # Test complete workflow:
        # 1. Scan script exists and runs
        # 2. Results are generated
        # 3. CI/CD is configured
        # 4. Pre-commit hook is available

        workflow_complete = all([
            (self.scripts_dir / "vulnerability_scan.py").exists(),
            (self.workflows_dir / "vulnerability-scan.yml").exists(),
            (self.scripts_dir / "pre_commit_vulnerability_check.sh").exists()
        ])

        self.log_test(
            "Complete vulnerability scanning workflow",
            workflow_complete,
            "All components (script, CI/CD, pre-commit) are in place"
        )

        return workflow_complete

    def run_all_tests(self) -> bool:
        """Run all validation tests"""
        print("\n" + "="*80)
        print("FEATURE #60 VALIDATION: VULNERABILITY SCANNING")
        print("="*80)

        tests = [
            self.test_pip_audit_installed,
            self.test_scan_all_services,
            self.test_vulnerability_scan_script,
            self.test_ci_cd_integration,
            self.test_pre_commit_hook,
            self.test_scan_results_format,
            self.test_documentation,
            self.test_complete_workflow
        ]

        results = []
        for test in tests:
            try:
                result = test()
                results.append(result)
            except Exception as e:
                print(f"❌ Test failed with exception: {e}")
                results.append(False)

        return all(results)

    def print_summary(self):
        """Print test summary"""
        print("\n" + "="*80)
        print("TEST SUMMARY")
        print("="*80)

        passed = sum(1 for r in self.test_results if r["passed"])
        total = len(self.test_results)

        print(f"\nTests Passed: {passed}/{total}")

        if passed == total:
            print("\n✅ ALL TESTS PASSED - Feature #60 is complete!")
            print("\nVulnerability scanning is fully implemented:")
            print("  ✅ pip-audit scans all Python dependencies")
            print("  ✅ No critical vulnerabilities detected")
            print("  ✅ Automated scanning script available")
            print("  ✅ CI/CD integration configured")
            print("  ✅ Pre-commit hook available")
            print("  ✅ Scan results properly formatted")
            print("  ✅ Documentation in place")
            return True
        else:
            print(f"\n❌ TESTS FAILED: {total - passed} tests did not pass")
            print("\nFailed tests:")
            for result in self.test_results:
                if not result["passed"]:
                    print(f"  ❌ {result['test']}")
                    if result["details"]:
                        print(f"     {result['details']}")
            return False


def main():
    validator = Feature60Validator()
    success = validator.run_all_tests()
    validator.print_summary()

    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
